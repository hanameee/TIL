# 쿠버네티스

### Linux 컨테이너란?

시스템의 나머지 부분과 격리된 프로세스 세트이다. 이러한 프로세스를 실행하는 데 필요한 모든 파일은 고유한 **이미지**에서 제공되므로, Linux 컨테이너는 개발부터 프로덕션까지 이식성과 일관성을 유지할 수 있다.

컨테이너는 동일한 운영 체제 커널을 공유하고, 시스템의 나머지 부분으로부터 애플리케이션 프로세스를 격리한다. 하이퍼바이저를 사용해 여러 하드웨어를 에뮬레이션하고 운영 체제를 동시에 실행하는 가상화와는 달리, Linux 컨테이너는 운영 체제에서 기본으로 실행되고 모든 컨테이너 전체에서 운영 체제를 공유하므로 애플리케이션과 서비스를 가볍게 유지할 수 있으며 빠른 속도로 동시에 실행할 수 있다. 

![가상화와 컨테이너 비교](https://www.redhat.com/cms/managed-files/virtualization-vs-containers.png)

### 쿠버네티스(k8s)란?

Linux 컨테이너 작업을 자동화하는 오픈소스 플랫폼이다. 도커 컨테이너를 직접 하드웨어에 배포하는 대신, 쿠버네티스를 사용하는 이유는 VM/하드웨어의 수가 많아지고 컨테이너의 수가 많아지면 컨테이너들을 어디에 배포해야하는지에 대한 결정이 필요하기 때문이다.

컨테이너를 적절한 서버에 배포해주는 것을 스케줄링이라고 하는데, 쿠버네티스는 이런 스케줄링 뿐만 아니라 컨테이너가 정상적으로 작동하고 있는지 체크해주고, 문제가 있으면 재가동해주고, 모니터링, 삭제관리 등 컨테이너에 대한 종합적인 관리를 해준다.

## Object

오브젝트는 쿠버네티스 시스템에서 영속성을 가지는 개체이다. 하나의 의도를 담은 레코드인 오브젝트는 클러스터의 상태를 나타내기 위해 사용된다. 오브젝트에는 기본적인 구성단위가 되는 **기본 오브젝트**와, 이 기본 오브젝트를 생성하고 관리하는 추가적인 기능을 가진 **컨트롤러**가 있다.

### 오브젝트 스펙 (Object Spec)

오브젝트들은 모두 오브젝트의 설정정보를 기술한 오브젝트 스펙으로 정의된다. cli를 통해 오브젝트 생성 시 인자로 전달하거나, yaml/json으로 스펙을 정의할 수 있다.

### 기본 오브젝트

쿠버네티스에 의해서 배포 및 관리되는 가장 기본적인 오브젝트는 Pod,Service,Volume,Namespace 4가지가 있다. 각각의 오브젝트에 대해 간단히 설명하자면 Pod는 컨테이너화된 애플리케이션, Volume은 디스크, Service는 로드밸런서, Namespace는 패키지명 정도로 생각하면 된다.

#### Pod

Pod는 쿠버네티스의 가장 기본적인 배포 단위로, 하나 이상의 컨테이너를 포함한다.

간단하게 pod를 정의한 오브젝트 스펙은 아래와 같다.

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx:1.7.9
    ports:
    - containerPort: 8090
```

#### Volume

Pod는 기동할 때 컨테이너마다 로컬 디스크를 생성한다. 그런데 이 로컬 디스크의 겨우, 컨테이너가 재시작되거나 새로 배포될 때마다 새롭게 정의되어 배포되기에 영구적이지 못하다. (디스크에 기록된 내용이 유실된다) DB와 같이 컨테이너 재시작에 상관없이 영구적으로 파일을 저장해야 하는 경우, volume을 사용하면 된다.

볼륨은 컨테이너의 외장 디스크 역할을 해주는 오브젝트로, pod가 기동할 때 컨테이너에 마운트해서 사용한다. 볼륨은 Pod 내의 컨테이너간의 공유가 가능하다.

#### Service

일반적인 분산 환경에서는 여러개의 Pod를 서비스하면서, 이를 로드밸런서를 이용하여 하나의 IP와 포트로 묶어서 서비스를 제공한다.  그런데 Pod의 경우 동적으로 생성되고 장애가 생기면 자동으로 재시작되면서 IP가 바뀌기 때문에, 로드밸런서에서 Pod의 목록을 지정할 때 IP주소를 이용하는 것은 어렵다. 또한, 오토스케일링으로 인해 동적으로 추가/삭제되는 Pod들을 로드밸런서가 유연하게 선택해주어야 한다.

그래서 사용하는 것이 Service의 Label과 Label Selector이라는 개념이다.

```yaml
kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  selector:
    app: myapp
  ports:
  - protocol: TCP
    port: 80
    targetPort: 9376
```

selector에서 label이 app:myapp인 pod만을 선택해서 서비스에서 서비스를 제공하게 하고, 포트는 TCP를 이용해 서비스의 80 포트의 요청을 컨테이너의 9376 포트로 연결해서 서비스를 제공한다.

#### Namespace

쿠버네티스는 동일 물리 클러스터를 기반으로 하는 복수의 가상 클러스터를 지원하는데, 이 가상 클러스터를 네임스페이스라고 칭한다.

네임스페이스는 하나의 쿠버네티스 **클러스터 내의 논리적인 분리단위**이다. Pod, Service 등은 네임스페이스별로 생성/관리될 수 있고, 사용자의 권한 역시 이 네임스페이스 별로 나눠서 부여할 수 있다.

단, 네임스페이스는 논리적인 분리 단위이고 물리적으로, 혹은 기타 장치를 통해 환경을 분리한 것이 아니다. 네트워크 정책을 이용해 네임스페이스 간의 통신을 막을 순 있지만, 높은 수준의 분리 정책을 원하는 경우 쿠버네티스 클러스터 자체를 분리하는 것을 권장한다.

### 컨트롤러

앞의 4개의 기본 오브젝트(Pod,Service,Volume,Namespace)로 애플리케이션을 설정하고 배포하는 것이 가능하지만, 이를 좀 더 편리하게 관리하기 위해 쿠버네티스는 컨트롤러라는 개념을 사용한다.

컨트롤러는 기본 오브젝트들을 생성하고 관리하는 역할을 해주며, 그 종류에는 Replication Controller (aka.RC), ReplicaSet, DaemonSet, Job, StatefulSet, Deployment 들이 있다.

#### Replication Controller, ReplicaSet

Replication Controller은 Pod를 관리해주는 역할을 한다. 지정된 숫자로 Pod를 기동시키고, 관리한다. ReplicaSet은 Replication Controller의 새 버전이다. (Replication Controller 는 Equality 기반 Selector를 이용하는데 반해, Replica Set은 Set 기반의 Selector를 이용한다는 차이가 있다)

#### Deployment

Deployment는 Replication controller와 Replica Set의 상위 추상화 개념으로, 실무에서는 Deployment가 많이 사용된다. Deployment는 Pod 배포를 위해서 RC를 생성하고 관리하는 역할을 하며, 특히 롤백을 위한 기존 버전의 RC 관리 등 여러가지 기능을 포괄하고 있다.

## Hardware

### Nodes

쿠버네티스에서 Node는 컴퓨팅 하드웨어의 가장 작은 단위를 뜻하며, 클러스터 내부의 하나의 머신을 나타낸다. 대부분의 프로덕션 시스템에서 노드는 데이터센터의 물리적인 머신이거나, GCP와 같은 클라우드 제공자로부터 호스팅되는 가상머신이다.

이렇게 머신을 노드로 추상화시키면, 우리는 각각의 머신을 활용 가능한 CPU와 RAM 리소스의 합으로 생각할 수 있다.

쿠버네티스에서는 클러스터 내부의 개별 노드 하나하나의 상태에 대해 신경쓰는 대신, 클러스터 전체를 하나로 생각한다. 우리가 클러스터에 프로그램을 배포하면, 쿠버네티스는 똑똑하게 프로그램을 개별 노드들에 배포한다. 만약 특정 노드가 추가되거나 삭제되면, 클러스터는 이에 유연하게 대응한다. 

### 클러스터란?

쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하기 위한 일련의 노드 머신이다. (쿠버네티스 실행 중 = 클러스터 실행 중)

클러스터의 구조는 아래와 같다.

<img src="https://t1.daumcdn.net/cfile/tistory/99172C485B02D9C82A" alt="img" style="zoom:67%;" />

클러스터에는 마스터와 워커 노드가 (마스터 노드, 작업자 노드) 포함된다. 클러스터 전체를 관리하는 컨트롤러로써 마스터가 존재하고, 컨테이너가 배포되는 머신 (가상머신이나 물리적인 서버 머신)인 노드가 존재한다.

## Software

### Containers

쿠버네티스에서 돌아가는 프로그램들은 리눅스 컨테이너로 싸여져있다. (Containerization) Containerization으로 인해 self-contained 리눅스 실행환경을 만드는 것이 가능하다. 어떤 프로그램이던지, 그 모든 의존성들이 하나의 파일로 번들되어 인터넷에 공유될 수 있다.

하나의 컨테이너에 여러개의 프로그램이 추가되는 것도 가능하지만, 가급적 하나의 컨테이너에 한개의 프로세스만 있는 것이 업데이트, 배포, 이슈 처리에 용이하다.

### Pods

쿠버네티스의 가장 기본적인 배포 단위로, 하나 이상의 컨테이너를 포함하는 단위이다. 쿠버네티스는 컨테이너를 바로 배포하는 것이 아니라, 하나 이상의 컨테이너를 pod라는 단위로 감싸 배포한다.

같은 pod 안의 컨테이너는 같은 리소스와 로컬 네트워크를 공유한다. 같은 pod안에 있는 container들 끼리는 (실제로는 분리되어 있지만) 마치 같은 머신에 있는 것처럼 쉽게 소통할 수 있다.

Pods 내에는 여러개의 컨테이너가 있을 수 있지만, 가급적 pod는 최소한의 컨테이너만을 가지는 것이 좋다. 그 이유는 pod 단위로 스케일이 커지고/작아지기에, 스케일업이 불필요한 컨테이너들도 스케일업이 되어 리소스의 낭비가 일어날 수 있기 때문이다. 

이에 주로 pod는 메인 프로세스와, 메인 프로세스와 깊게 연관된 헬퍼 컨테이너들(side-cars)로 구성된다. 이렇게 애플리케이션과 애플리케이션에서 사용하는 주변 프로그램을 같이 배포하는 패턴을 마이크로 서비스 아키텍쳐에서 사이드카 패턴(Side car pattern)이라고 한다.

### Deployments

pod가 쿠버네티스에서 연산의 기본 단위지만, 직접적으로 클러스터에서 실행되는 것은 pod가 아니라 pod에서 한 단계 더 추상화된 deployment이다.

<img src="https://miro.medium.com/max/8068/1*iTAVk3glVD95hb-X3HiCKg.png" alt="Image for post" style="zoom: 50%;" />

Deployment는 기본적으로 얼마나 많은 pod의 복제본이 돌아갈지를 명시하는 용도이다.

클러스트에 deployment가 추가되면 클러스터는 자동으로 명시된 갯수만큼 pod를 돌리고, 모니터한다. 만약 pod가 죽으면 deployment는 자동으로 pod를 재생성한다.

Deployment를 사용하면 pods를 수동으로 다룰 필요가 없고, 단지 시스템에 필요한 pod의 갯수만을 명시해주면 된다.

## References

[쿠버네티스 #2 - 개념 이해 (1/2)](https://bcho.tistory.com/1256?category=731548)

[Kubernetes 101: Pods, Nodes, Containers, and Clusters](https://medium.com/google-cloud/kubernetes-101-pods-nodes-containers-and-clusters-c1509e409e16)

[쿠버네티스 Object 살펴보기1 Pod/Service/Volume - 기초(2)](https://baek.dev/post/6/)