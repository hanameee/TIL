# 🐳 Docker 공식문서

링크: https://docs.docker.com/

## [Part1. Orientation and setup](https://docs.docker.com/get-started/)

### DockerCon 2020 영상 [링크](https://youtu.be/iqqDU2crIEQ)

도커는 서버를 다루는 새로운 패러다임을 제시한다. 바로, 서버를 **Ephemeral** (단명한 것) 으로 보는 것. 서버가 죽거나,  장애가 생기면 patch나 update를 하는게 아니라 그냥 다른 이미지로 대체하면 된다.

도커에는 3단계가 있다.

1) Build Image - 어플리케이션이 동작하기 위해 필요한 모든 것을 consistently package한다.

2) Ship Image - build된 이미지를 클라우드나 로컬 개발 머신에서 runtime으로 ship한다.

3) Run Image - image를 가지고 편리하게 어플리케이션을 실행한다.

#### Dockerfile

`Dockerfile` 은 도커 이미지를 빌드하기 위해 사용된다. `Dockerfile` 은 도커 엔진으로 보내지는 명령어들의 조합이고, 도커 엔진은 이 명령어들을 위에서부터 하나씩 실행해 도커 이미지를 빌드한다.

```dockerfile
// 시작할 base image (verified) - 우리의 어플리케이션은 이 base image위에 쌓이게 된다
FROM node:12.16.3

// working directory - 이 디렉토리를 만들고 이후의 명령어들은 이 디렉토리를 기준으로 실행됨
WORKDIR /code

// PORT라는 환경변수를 만들고 그 값으로 80을 지정 - 이 이미지 내부의 모든 프로세스들이 접근할 수 있다
ENV PORT 80

// package.json 파일을 /code/package.json 으로 복사
COPY package.json /code/package.json

// 예
RUN npm install

// 현재 디렉토리(.)에 있는 모든 파일을 이미지(/code)로 복사
COPY . /code

// command - 도커 엔진이 컨테이너를 시작할 때 실행할 명령어들
CMD ["node", "src/server.js"]
```

#### Docker build

docker build와 관련된 명령어들은

```bash
docker build --help
# Usage:  docker build [OPTIONS] PATH | URL | -
```

이 명령어로 확인할 수 있다.

```
docker build --tag sample-node-app .
```

위 명령어를 실행하면 Dockerfile의 명령어들이 하나하나 실행되면서 도커 이미지가 만들어지는 것을 볼 수 있다.

<img src="공식문서.assets/image-20201223230902772.png" alt="image-20201223230902772" style="zoom:50%;" />

로컬 머신에 있는 이미지들은 아래 명령어로 확인할 수 있다.

```
docker images
```

<img src="공식문서.assets/image-20201223231056450.png" alt="image-20201223231056450" style="zoom:50%;" />

#### Docker run

이제 도커 이미지를 어떻게 만들지 알려주는 Dockerfile도 있고, 이 Dockerfile을 가지고 이미지를 build 했다. 이제 이 이미지를 run 하면 됨.

Docker run과 관련된 명령어들은 아래 명령어로 확인할 수 있다.

```bash
docker run --help
# Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

기본적으로 빌드하고 싶은 이미지의 이름을 넘겨주면 된다.

```
docker run sample-node-app
```

### Start the tutorial

```
docker run -d -p 80:80 docker/getting-started
```

`docker/getting-started` 이미지가 로컬에 존재하지 않으므로, docker hub라는 중앙 이미지 저장소에서 이미지를 내려받게 된다.

- `-d` : run the container in detached mode (in the background)
- `-p 80:80`: map port 80 of the host to port 80 in the container
- `docker/getting-started` : the image to use

위 명령어를 실행하고 나면, 도커 대시보드에서 이미지와, 실행중인 컨테이너를 확인할 수 있다.

#### 컨테이너란?

> a container is simply another process on your machine that has been isolated from all other processes on the host machine.

호스트 머신의 다른 모든 프로세스로부터 독립된 프로세스로, 내부적으로는 linux의 기능인 [kernel namespaces and cgroups](https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504)를 사용한다.

#### 컨테이너 이미지란?

컨테이너를 run 할 때, 컨테이너는 독립된 filesystem을 이용한다. 이 독립된 filesystem은 컨테이너 이미지로부터 제공된다.

이미지는 컨테이너를 실행하기 위해 필요한 모든 것(all dependencies, configuration, scripts, binaries, etc.)들과, 필요한 환경설정(환경변수, 실행할 명령어, metadata 등)을 가지고 있다.

## [Part2. Our app](https://docs.docker.com/get-started/02_our_app/)

1. Dockerfile을 작성한다.

   ```dockerfile
   FROM node:12-alpine
   WORKDIR /app
   COPY . .
   RUN yarn install --production
   CMD ["node", "src/index.js"]
   ```

2. Dockerfile을 바탕으로 Container Image를 빌드한다.

   ```bash
   docker build -t getting-started .
   ```

3. 이미지를 run해 컨테이너를 시작한다.

   ```bash
   docker run -dp 3000:3000 getting-started
   ```


## [Part3. Updating our Application](https://docs.docker.com/get-started/03_updating_app/)

App에 어떤 변경사항이 생겼다고 가정하자. 이 변경사항을 반영하려면 어떻게 해야할까?

1. 변경사항을 수정한다.

2. 수정한 변경사항을 반영한 이미지를 다시 build 한다.

   ```bash
   docker build -t getting-started .
   ```

3. 기존에 돌고 있던 컨테이너를 stop하고, 제거한다.

   ```bash
   # 돌고 있는 도커 컨테이너들의 ID를 받아오는 명령어
   docker ps
   docker stop <container-id>
   docker rm <container-id>
   ```

   ⚠️ 참고 - `docker rm -f <container-id>` 명령어로 컨테이너의 중지와 삭제를 한꺼번에 할 수 있다.

4. 변경사항을 반영한 이미지로 다시 컨테이너를 띄운다.

   ```bash
   docker run -dp 3000:3000 getting-started
   ```

이 일련의 작업들을 해주고 localhost:3000으로 가보면 변경사항이 반영된 앱이 떠 있는 것을 볼 수 있다. 그런데 지금 이렇게 작은 업데이트를 해주기가 굉장히 번거롭기도 하고, 무엇보다 앱의 기존 상태 
(Todo)가 다 삭제된 것을 볼 수 있다.

요건 바람직한 업데이트라고 보기 힘듬. 개선된 방법을 나중에 배울것!

## [Part4. Sharing our Application](https://docs.docker.com/get-started/04_sharing_app/)

노드 패키지를 npm에 공유하듯, 도커 이미지는 Docker registry에 공유할 수 있다. 별도의 설정이 없다면 Docker registry의 기본값은 [docker hub](https://hub.docker.com/)이다. 빌드한 이미지를 docker hub에 공유해보자!

Docker hub에 가서 Repository를 만들면, 요런 안내문을 볼 수 있다.

<img src="공식문서.assets/image-20210105222323214.png" alt="image-20210105222323214" style="zoom:50%;" />

`docker push 유저이름/getting-started:tagname` 명령어로 docker hub의 내 repo - 여기서는 getting-started - 에 이미지를 push 할 수 있다.

그런데, `docker image ls` 를 해보면, 로컬에 `hanameee/getting-started` 라는 이미지는 없다.

![image-20210105222825729](공식문서.assets/image-20210105222825729.png)

내 docker hub 레포에 이미지를 push 하기 위해서는 우리가 만든 저 `getting-started`를 **tag**해서   새로운 이름(`유저이름/getting-started`)을 부여해줘야 한다.

먼저 docker hub에 로그인을 한뒤 (`docker login -u 유저이름`)

```bash
docker tag getting-started 유저이름/getting-started
```

`docker tag 기존이미지이름 새이미지이름` 명령어로 새로운 이름이 부여된 이미지를 만들 수 있다.

그리고 push를 해주면

```bash
 docker push 유저이름/getting-started
```

원격 docker hub 레포에 이미지가 잘 올라가는 것을 확인할 수 있다.

이렇게 원격 docker hub에 이미지를 올리고 나면, 도커만 설치되어 있는 환경이라면 어디서든 방금 내가 올린 `hanameee/getting-started` 이미지를 내려받아 띄울 수 있다.

https://labs.play-with-docker.com/ 에서 실습해보자!

도커 계정으로 로그인 후, 해당 페이지의 터미널에서 아래 명령어로 docker run을 하면

```
docker run -dp 3000:3000 hanameee/getting-started
```

이미지가 docker hub에서 내려받아진 후 해당 서버의 3000포트로 띄워지는 것을 볼 수 있다. 넘나 재밌다...😳

## [Part5. Persisting our DB](https://docs.docker.com/get-started/05_persisting_data/)

지금은 컨테이너를 띄울 때마다 리스트가 초기화된다. 왜 그럴까?

### 컨테이너의 파일시스템

컨테이너를 처음 띄우면, 이미지의 다양한 레이어를 바탕으로 해당 컨테이너의 파일시스템을 구성한다. (When a container runs, it uses the various layers from an image for its filesystem.) 그러나 컨테이너를 띄운 후의 변경사항은 해당 컨테이너 내에서만 유효하다. 

컨테이너들은 각자 파일 생성/수정/삭제를 위한 자신만의 scratch space를 가지기 때문에, 같은 이미지로 띄운 컨테이너들이라도 각자의 고유한 변경사항을 가지기 때문이다.

컨테이너는 이렇게 각자의 고유한 변경사항을 가지고, 컨테이너가 삭제되면 이 변경사항들도 사라진다. 

### Container volumes

Volumes를 이용하면, 컨테이너의 특정 파일시스템 경로를 호스트 머신과 연결할 수 있다. 컨테이너의 디렉토리가 변경되면, 그 변경사항이 호스트 머신에도 반영되는 것! 이후에 컨테이너가 재시작 될 때도 같은 디렉토리를 마운트(attach)하면, 변경사항을 계속해서 유지할 수 있다.

named volumes를 이용해 우리 todo app의 데이터를 유지해보자!

### 실습

1. volume을 생성한다.

   ```bash
   docker volume create todo-db
   ```

2. 기존에 컨테이너가 돌고 있었다면, 멈춰준다.

   ```bash
   docker rm -f <컨테이너아이디>
   ```

3. 컨테이너를 실행하되, `-v` 플래그로 volume mount를 명시해준다.

   ```bash
   docker run -dp 3000:3000 -v todo-db:/etc/todos hanameee/getting-started
   ```

4. 변경사항을 발생시키고 컨테이너를 삭제한다 (2번과 동일)
5. 3번과 동일한 명령어로 컨테이너를 실행한다

이렇게 volume을 이용해서 데이터를 보존할 수 있다.

### named volume의 데이터는 실제로 어디에 저장되는가?

`docker volume inspect <named-volume-이름>` 명령어를 통해 실제로 Docker이 volume의 데이터를 어디에 보관하는지 파악할 수 있다.

<img src="공식문서.assets/image-20210107214131436.png" alt="image-20210107214131436" style="zoom:50%;" />

`Mountpoint` 에 나오는 경로가 그것인데, 실제로 터미널에서 해당 위치에 가보려고 하면 없는 경로다? 😳

그 이유는 내가 Docker for Mac 앱을 이용하고 있기 때문이다. 리눅스와는 달리, Docker는 macOS와 natively compatible 하지 않다. 사실 Docker는 내 호스트 머신이 아니라 호스트 머신 위의 가상환경에서 실행되고 있다는 사실...!

Docker Desktop for Mac은 [Hyperkit](https://github.com/moby/hyperkit)을 이용해 가상 이미지를 실행중인데, 가상 이미지 데이터는 `~/Library/Containers/com.docker.docker/Data/vms/0` 요기에 위치하고 있다.

우리는 이 가상 이미지를 실행시킨 후에, 저 위에 보이는 `Mountpoint` 경로를 들어가야 volume에 저장된 데이터를 볼 수 있는 것임!

```bash
$ screen ~/Library/Containers/com.docker.docker/Data/vms/0/tty 
```

(음... tty까지 실행은 시켰는데 이 이후에 Mountpoint로 navigate 하는게 안된다...😨 더 찾아봐야겠다아...이건 리눅스의 screen을 알아야 이해가 될 것 같음. 아이고 두야...)

출처: https://www.freecodecamp.org/news/where-are-docker-images-stored-docker-container-paths-explained/

### 예고) bind mounts

Docker engine은 대표적으로 두 종류의 volume을 지원하는데, 여기에는 방금 우리가 데이터를 유지하기 위해 사용한 **named volume**과 또 하나의 종류인 **bind mounts**가 있다.

우리가 Part3에서 어플리케이션에 발생한 수정사항을 반영하기 위해 이미지를 rebuild 했었다. 그런데, 어플리케이션에 변경사항이 생길때마다 수정사항을 반영한 이미지를 다시 빌드하는 것은 시간도 많이 걸리고 별로임. 여기서 bind mounts를 사용하면 좀 더 좋은 방법으로 어플리케이션을 업데이트 할 수 있다.

## [Part6. Using bind mounts](https://docs.docker.com/get-started/06_bind_mounts/)

Ch5에서 데이터베이스에 데이터를 유지하기 위해 `named volume`을 사용했었다. named volume은 데이터가 **어디** 저장되는지 신경쓰지 않고 데이터를 저장하기에는 훌륭하다.

반면, `bind mounts`는 host의 정확한 mountpoint를 컨트롤할 수 있다. 이 mountpoint는 데이터를 유지하기 위해 사용할 수도 있지만, 컨테이너에 추가적인 데이터를 제공하기 위해서 더 자주 사용한다.

소스코드를 우리의 컨테이너에 mount 하기 위해 bind mount를 이용한다. 

### Volume 타입 비교

도커 엔진의 대표적인 볼륨의 종류는 Bind mounts, named volumes 이다. 하지만 다른 사용처를 위한 추가적인 볼륨 드라이버들도 존재한다. ([SFTP](https://github.com/vieux/docker-volume-sshfs), [Ceph](https://ceph.com/geen-categorie/getting-started-with-the-docker-rbd-volume-plugin/), [NetApp](https://netappdvp.readthedocs.io/en/stable/), [S3](https://github.com/elementar/docker-s3-volume) 등...)

|                                              | Named Volumes             | Bind Mounts                   |
| :------------------------------------------- | :------------------------ | :---------------------------- |
| 호스트 위치                                  | 도커가 결정한다           | 사용자가 컨트롤한다           |
| Mount 예시 (using `-v`)                      | my-volume:/usr/local/data | /path/to/data:/usr/local/data |
| Populates new volume with container contents | Yes                       | No                            |
| Volume Drivers 지원                          | Yes                       | No                            |

### Dev-Mode 컨테이너 시작하기

기존에 있던 getting-started-master 앱에서, 아래 방법으로 dev workflow를 지원하는 container을 돌려볼 것임.

- 소스코드를 컨테이너에 mount한다.
- devdependencies를 포함한 dependencies를 설치한다.
- nodemon을 시작해서 filesystem 변화를 watch한다.

1. 기존에 돌고 있는 컨테이너를 다 내린다.

2. getting-started-master 앱의 root 폴더에서 아래 명령어를 실행한다. 

   ```bash
   docker run -dp 3000:3000 \
        -w /app -v "$(pwd):/app" \
        node:12-alpine \
     sh -c "yarn install && yarn run dev"
   
   ```

   - `-dp 3000:3000` : 컨테이너를 detached (background) mode에서 run하고, port mapping을 만들어라.
   - `-w /app` : working directory를 /app으로 설정해라. 이후의 명령어들은 해당 디렉토리를 기준으로 실행될 것임.
   - `-v "$(pwd):/app"` : [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉토리] 를 공유한다는 뜻. 여기서는 호스트의 현재 디렉토리를 컨테이너의 /app 디렉토리와 공유하라는 것.
   - `node:12-alpine`: 사용할 이미지. 
   - `sh -c "yarn install && yarn run dev"` : 명령어. sh를 통해 shell을 시작하고 (alpine은 bash가 없음), yarn install로 모든 의존성을 설치하고, yarn run dev로 nodemon을 실행한다.
3. `docker logs -f <container-id>` 명령어로 logs를 볼 수 있다.


이렇게 컨테이너를 띄운 후, 기존 소스코드를 수정한 뒤 (ex. Add item 버튼을 Add로 수정) 새로고침을 하면 Node server가 다시 실행되면서 수정사항이 바로 반영된 것을 볼 수 있다.

이렇게 local development setup을 할 때 bind mount를 사용하는 것은 아주 흔하다. Dev machine에 빌드 툴이나 환경이 설치되어 있을 필요 없이, docker run만을 통해서 개발환경을 세팅할 수 있다.

이후에 배울 Docker Compose까지 활용하면 위에처럼 -dp -w -v 등등 다양한 플래그가 포함된 복잡한 명령어를 칠 필요 없이, 명령어를 간략화할 수 있다.

