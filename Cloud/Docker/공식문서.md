# 🐳 Docker 공식문서

링크: https://docs.docker.com/

## [Part1. Orientation and setup](https://docs.docker.com/get-started/)

### DockerCon 2020 영상 [링크](https://youtu.be/iqqDU2crIEQ)

도커는 서버를 다루는 새로운 패러다임을 제시한다. 바로, 서버를 **Ephemeral** (단명한 것) 으로 보는 것. 서버가 죽거나,  장애가 생기면 patch나 update를 하는게 아니라 그냥 다른 이미지로 대체하면 된다.

도커에는 3단계가 있다.

1) Build Image - 어플리케이션이 동작하기 위해 필요한 모든 것을 consistently package한다.

2) Ship Image - build된 이미지를 클라우드나 로컬 개발 머신에서 runtime으로 ship한다.

3) Run Image - image를 가지고 편리하게 어플리케이션을 실행한다.

#### Dockerfile

`Dockerfile` 은 도커 이미지를 빌드하기 위해 사용된다. `Dockerfile` 은 도커 엔진으로 보내지는 명령어들의 조합이고, 도커 엔진은 이 명령어들을 위에서부터 하나씩 실행해 도커 이미지를 빌드한다.

```dockerfile
// 시작할 base image (verified) - 우리의 어플리케이션은 이 base image위에 쌓이게 된다
FROM node:12.16.3

// working directory - 이 디렉토리를 만들고 이후의 명령어들은 이 디렉토리를 기준으로 실행됨
WORKDIR /code

// PORT라는 환경변수를 만들고 그 값으로 80을 지정 - 이 이미지 내부의 모든 프로세스들이 접근할 수 있다
ENV PORT 80

// package.json 파일을 /code/package.json 으로 복사
COPY package.json /code/package.json

// 예
RUN npm install

// 현재 디렉토리(.)에 있는 모든 파일을 이미지(/code)로 복사
COPY . /code

// command - 도커 엔진이 컨테이너를 시작할 때 실행할 명령어들
CMD ["node", "src/server.js"]
```

#### Docker build

docker build와 관련된 명령어들은

```bash
docker build --help
# Usage:  docker build [OPTIONS] PATH | URL | -
```

이 명령어로 확인할 수 있다.

```
docker build --tag sample-node-app .
```

위 명령어를 실행하면 Dockerfile의 명령어들이 하나하나 실행되면서 도커 이미지가 만들어지는 것을 볼 수 있다.

<img src="공식문서.assets/image-20201223230902772.png" alt="image-20201223230902772" style="zoom:50%;" />

로컬 머신에 있는 이미지들은 아래 명령어로 확인할 수 있다.

```
docker images
```

<img src="공식문서.assets/image-20201223231056450.png" alt="image-20201223231056450" style="zoom:50%;" />

#### Docker run

이제 도커 이미지를 어떻게 만들지 알려주는 Dockerfile도 있고, 이 Dockerfile을 가지고 이미지를 build 했다. 이제 이 이미지를 run 하면 됨.

Docker run과 관련된 명령어들은 아래 명령어로 확인할 수 있다.

```bash
docker run --help
# Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```

기본적으로 빌드하고 싶은 이미지의 이름을 넘겨주면 된다.

```
docker run sample-node-app
```

### Start the tutorial

```
docker run -d -p 80:80 docker/getting-started
```

`docker/getting-started` 이미지가 로컬에 존재하지 않으므로, docker hub라는 중앙 이미지 저장소에서 이미지를 내려받게 된다.

- `-d` : run the container in detached mode (in the background)
- `-p 80:80`: map port 80 of the host to port 80 in the container
- `docker/getting-started` : the image to use

위 명령어를 실행하고 나면, 도커 대시보드에서 이미지와, 실행중인 컨테이너를 확인할 수 있다.

#### 컨테이너란?

> a container is simply another process on your machine that has been isolated from all other processes on the host machine.

호스트 머신의 다른 모든 프로세스로부터 독립된 프로세스로, 내부적으로는 linux의 기능인 [kernel namespaces and cgroups](https://medium.com/@saschagrunert/demystifying-containers-part-i-kernel-space-2c53d6979504)를 사용한다.

#### 컨테이너 이미지란?

컨테이너를 run 할 때, 컨테이너는 독립된 filesystem을 이용한다. 이 독립된 filesystem은 컨테이너 이미지로부터 제공된다.

이미지는 컨테이너를 실행하기 위해 필요한 모든 것(all dependencies, configuration, scripts, binaries, etc.)들과, 필요한 환경설정(환경변수, 실행할 명령어, metadata 등)을 가지고 있다.

## [Part2. Our app](https://docs.docker.com/get-started/02_our_app/)

1. Dockerfile을 작성한다.

   ```dockerfile
   FROM node:12-alpine
   WORKDIR /app
   COPY . .
   RUN yarn install --production
   CMD ["node", "src/index.js"]
   ```

2. Dockerfile을 바탕으로 Container Image를 빌드한다.

   ```bash
   docker build -t getting-started .
   ```

3. 이미지를 run해 컨테이너를 시작한다.

   ```bash
   docker run -dp 3000:3000 getting-started
   ```


## [Part3. Updating our Application](https://docs.docker.com/get-started/03_updating_app/)

App에 어떤 변경사항이 생겼다고 가정하자. 이 변경사항을 반영하려면 어떻게 해야할까?

1. 변경사항을 수정한다.

2. 수정한 변경사항을 반영한 이미지를 다시 build 한다.

   ```bash
   docker build -t getting-started .
   ```

3. 기존에 돌고 있던 컨테이너를 stop하고, 제거한다.

   ```bash
   # 돌고 있는 도커 컨테이너들의 ID를 받아오는 명령어
   docker ps
   docker stop <container-id>
   docker rm <container-id>
   ```

   ⚠️ 참고 - `docker rm -f <container-id>` 명령어로 컨테이너의 중지와 삭제를 한꺼번에 할 수 있다.

4. 변경사항을 반영한 이미지로 다시 컨테이너를 띄운다.

   ```bash
   docker run -dp 3000:3000 getting-started
   ```

이 일련의 작업들을 해주고 localhost:3000으로 가보면 변경사항이 반영된 앱이 떠 있는 것을 볼 수 있다. 그런데 지금 이렇게 작은 업데이트를 해주기가 굉장히 번거롭기도 하고, 무엇보다 앱의 기존 상태 
(Todo)가 다 삭제된 것을 볼 수 있다.

요건 바람직한 업데이트라고 보기 힘듬. 개선된 방법을 나중에 배울것!

## [Part4. Sharing our Application](https://docs.docker.com/get-started/04_sharing_app/)

노드 패키지를 npm에 공유하듯, 도커 이미지는 Docker registry에 공유할 수 있다. 별도의 설정이 없다면 Docker registry의 기본값은 [docker hub](https://hub.docker.com/)이다. 빌드한 이미지를 docker hub에 공유해보자!

Docker hub에 가서 Repository를 만들면, 요런 안내문을 볼 수 있다.

<img src="공식문서.assets/image-20210105222323214.png" alt="image-20210105222323214" style="zoom:50%;" />

`docker push 유저이름/getting-started:tagname` 명령어로 docker hub의 내 repo - 여기서는 getting-started - 에 이미지를 push 할 수 있다.

그런데, `docker image ls` 를 해보면, 로컬에 `hanameee/getting-started` 라는 이미지는 없다.

![image-20210105222825729](공식문서.assets/image-20210105222825729.png)

내 docker hub 레포에 이미지를 push 하기 위해서는 우리가 만든 저 `getting-started`를 **tag**해서   새로운 이름(`유저이름/getting-started`)을 부여해줘야 한다.

먼저 docker hub에 로그인을 한뒤 (`docker login -u 유저이름`)

```bash
docker tag getting-started 유저이름/getting-started
```

`docker tag 기존이미지이름 새이미지이름` 명령어로 새로운 이름이 부여된 이미지를 만들 수 있다.

그리고 push를 해주면

```bash
 docker push 유저이름/getting-started
```

원격 docker hub 레포에 이미지가 잘 올라가는 것을 확인할 수 있다.

이렇게 원격 docker hub에 이미지를 올리고 나면, 도커만 설치되어 있는 환경이라면 어디서든 방금 내가 올린 `hanameee/getting-started` 이미지를 내려받아 띄울 수 있다.

https://labs.play-with-docker.com/ 에서 실습해보자!

도커 계정으로 로그인 후, 해당 페이지의 터미널에서 아래 명령어로 docker run을 하면

```
docker run -dp 3000:3000 hanameee/getting-started
```

이미지가 docker hub에서 내려받아진 후 해당 서버의 3000포트로 띄워지는 것을 볼 수 있다. 넘나 재밌다...😳

## [Part5. Persisting our DB](https://docs.docker.com/get-started/05_persisting_data/)

지금은 컨테이너를 띄울 때마다 리스트가 초기화된다. 왜 그럴까?

### 컨테이너의 파일시스템

컨테이너를 처음 띄우면, 이미지의 다양한 레이어를 바탕으로 해당 컨테이너의 파일시스템을 구성한다. (When a container runs, it uses the various layers from an image for its filesystem.) 그러나 컨테이너를 띄운 후의 변경사항은 해당 컨테이너 내에서만 유효하다. 

컨테이너들은 각자 파일 생성/수정/삭제를 위한 자신만의 scratch space를 가지기 때문에, 같은 이미지로 띄운 컨테이너들이라도 각자의 고유한 변경사항을 가지기 때문이다.

컨테이너는 이렇게 각자의 고유한 변경사항을 가지고, 컨테이너가 삭제되면 이 변경사항들도 사라진다. 

### Container volumes

Volumes를 이용하면, 컨테이너의 특정 파일시스템 경로를 호스트 머신과 연결할 수 있다. 컨테이너의 디렉토리가 변경되면, 그 변경사항이 호스트 머신에도 반영되는 것! 이후에 컨테이너가 재시작 될 때도 같은 디렉토리를 마운트(attach)하면, 변경사항을 계속해서 유지할 수 있다.

named volumes를 이용해 우리 todo app의 데이터를 유지해보자!

### 실습

1. volume을 생성한다.

   ```bash
   docker volume create todo-db
   ```

2. 기존에 컨테이너가 돌고 있었다면, 멈춰준다

   ```bash
   docker rm -f <컨테이너아이디>
   ```

3. 컨테이너를 실행하되, `-v` 플래그로 volume mount를 명시해준다

   ```bash
   docker run -dp 3000:3000 -v todo-db:/etc/todos hanameee/getting-started
   ```

4. 변경사항을 발생시키고 컨테이너를 삭제한다 (2번과 동일)
5. 3번과 동일한 명령어로 컨테이너를 실행한다

이렇게 volume을 이용해서 데이터를 보존할 수 있다.